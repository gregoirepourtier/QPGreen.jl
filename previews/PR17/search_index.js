var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"B. Zhang and R. Zhang. An FFT-based algorithm for efficient computation of Green’s functions for the Helmholtz and Maxwell’s equations in periodic domains. SIAM Journal on Scientific Computing 40, B915 – B941 (2018).\n\n\n\nC. Linton. The Green's function for the two-dimensional Helmholtz equation in periodic domains. Journal of Engineering Mathematics 33, 377–401 (1998).\n\n\n\n","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We show here some examples on how to compute efficiently Quasi-periodic Green Functions and its first derivatives for the 2D Helmholtz equation. The main focus is on the FFT-based algorithm, but we also provide examples for the lattice sums and Ewald summation algorithms.","category":"page"},{"location":"examples/#Example-1:-FFT-based-algorithm","page":"Examples","title":"Example 1: FFT-based algorithm","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first example is concerned with computing the quasi-periodic Green function for the 2D Helmholtz equation using the FFT-based algorithm (based on the article [1]).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, load the package, using the following command:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QPGreen","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then initialize the different parameters, as a NamedTuple, that define your problems. We have","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Parameters\nparams = (α=0.3, k=1.0, c=0.6, c̃=1.0, ε=0.45, order=8)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"with the following parameters:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"α is the quasiperiod, \nk is the wavenumber, \nc and c̃ are coefficients introduced in the paper [1] that are used in the smooth cut-off functions and in order to determine if we use the classical eigenfunction expansion for the approximation or the FFT-based algorithm (if you evaluate your 2D Green function in a point x=(x_1 x_2) in mathbbR^2, then if x_2  c the we use the expansion, else the FFT-base algo).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note on the choice of c and c̃\nThe following inequality must hold:    0  c  tildec","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ε is used in the smooth cut-off functions, and \norder denote the regularity from the cut-off functions.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We set the grid size that is used to generate the 2D tensor product mesh (adjust for desired accuracy).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Size of the Grid\ngrid_size = 128\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This method relies on two steps: a preparation step and an evaluation step. ","category":"page"},{"location":"examples/#Preparation-step","page":"Examples","title":"Preparation step","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The preparation step, which is independent of the function evaluation at a point, computes various Fourier coefficients and returns an Extrapolation object along with a cache containing integral approximations. Note that you only need to perform the preparation step once for a given set of parameters and grid size.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Preparation Step\ninterpolation, cache = fm_method_preparation(params, grid_size)","category":"page"},{"location":"examples/#Evaluation-step","page":"Examples","title":"Evaluation step","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The evaluation step is used to compute the Green function for any given point in the periodic domain and is very efficient.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Evaluation Step for any points\nZ = (0.002π, 0.01)\neval_Green_function = fm_method_calculation(Z, params, interpolation, cache; nb_terms=32)\n@show \"The value of the Green function at the point $(Z) is: $(eval_Green_function)\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note here that the keyword argument nb_terms is used to control the number of terms in the eigenfunction expansion (in the case where the FFT-based algorithm is not used).","category":"page"},{"location":"examples/#Evaluation-of-the-first-derivatives-of-the-Green-function","page":"Examples","title":"Evaluation of the first derivatives of the Green function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the previous section, we explained how to compute efficiently the quasi-periodic Green function. We now show how to compute the first derivatives of the Green function. The method is similar to the one used before.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Supposing that we are using the same parameters and the same grid size, we can once again use the preparation step.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Preparation Step\ninterpolation_x1, interpolation_x2, cache = fm_method_preparation_derivative(params, grid_size);","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note here that we have two interpolations, one for the first derivative with respect to the first variable and the other for the second variable.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then, we can evaluate the first derivatives of the Green function at any point in the periodic domain.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Evaluation Step for any points\nZ = (0.002π, 0.01)\neval_Green_function_x1 = fm_method_calculation_derivative(Z, params, interpolation_x1, interpolation_x2, cache; nb_terms=32)","category":"page"},{"location":"examples/#Example-2:-Lattice-sums-algorithm","page":"Examples","title":"Example 2: Lattice sums algorithm","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"warning: Work in progress\nThis algorithm is still a work in progress.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The second algorithm implemented is the lattice sums algorithm (implementation was done based on the article [2]).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Once again, load the package, using the following command:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QPGreen","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then initialize the different parameters, as a NamedTuple, that define your problems. We have","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"X, Y = (0.0, 0.01 * 2π)\n\nβ, k, d, M, L = (√2 / (2 * π), 1 / π, 2 * π, 80, 4)\ncsts = (β, k, d, M, L)\n\nSl = QPGreen.lattice_sums_preparation(csts);\neval_ls = QPGreen.lattice_sums_calculation((X, Y), csts, Sl; nb_terms=100)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nThe implementation for the derivatives is missing at the moment.","category":"page"},{"location":"examples/#Example-3:-Ewald's-method","page":"Examples","title":"Example 3: Ewald's method","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"warning: Work in progress\nThis algorithm is still a work in progress.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The last algorithm implemented is the Ewald summation algorithm (implementation was done based on the article [2]).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Load the package, using the following command:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using QPGreen","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then initialize the different parameters, as a NamedTuple, that define your problems. We have","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(X, Y) = (0.0, 0.01 * 2π)\n\na, M₁, M₂, N, β, k, d = (2, 3, 2, 7, √2 / (2 * π), 1 / π, 2 * π)\ncsts = (a, M₁, M₂, N, β, k, d)\n\nres_ewald = QPGreen.ewald([X, Y], csts)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nThe implementation for the derivatives is missing at the moment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"docstrings/#QPGreen","page":"Docstrings","title":"QPGreen","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Documentation for QPGreen.","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"},{"location":"docstrings/#QPGreen.IntegrationCache","page":"Docstrings","title":"QPGreen.IntegrationCache","text":"struct IntegrationCache{T1<:Real, T2<:Signed} <: QPGreen.AbstractIntegrationCache\n\nStructure storing the normalization factor and the parameters of integration for the cutoff functions.\n\nnormalization::Real: Normalization factor\n\nparams::QPGreen.IntegrationParameters: Parameters of integration\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#QPGreen.IntegrationParameters","page":"Docstrings","title":"QPGreen.IntegrationParameters","text":"struct IntegrationParameters{T1<:Real, T2<:Signed}\n\nStructure storing the parameters of integration for the cutoff functions.\n\na::Real: Lower bound\n\nb::Real: Upper bound\n\norder::Signed: Order of the cutoff function\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#QPGreen.S_even-NTuple{5, Any}","page":"Docstrings","title":"QPGreen.S_even","text":"S_even(l, β, k, d, M)\n\nCompute the lattice sum Sₗ for even values of l. Input arguments:\n\nl: integer value.\nβ: parameter β.\nk: parameter k.\nd: parameter d.\nM: number of terms in the sum.\n\nReturns the value of the lattice sum Sₗ for even values of l.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.S_odd-NTuple{5, Any}","page":"Docstrings","title":"QPGreen.S_odd","text":"S_odd(l, β, k, d, M)\n\nCompute the lattice sum Sₗ for odd values of l.\n\nInput arguments:\n\nl: integer value.\nβ: parameter β.\nk: parameter k.\nd: parameter d.\nM: number of terms in the sum.\n\nReturns the value of the lattice sum Sₗ for odd values of l.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.S₀-NTuple{4, Any}","page":"Docstrings","title":"QPGreen.S₀","text":"S₀(β, k, d, M)\n\nCompute the lattice sum S₀.\n\nInput arguments:\n\nβ: parameter β.\nk: parameter k.\nd: parameter d.\nM: number of terms in the sum.\n\nReturns the value of the lattice sum S₀.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.Yε-Union{Tuple{T}, Tuple{T, QPGreen.IntegrationCache}} where T","page":"Docstrings","title":"QPGreen.Yε","text":"Yε(x, cache)\n\nBuild the cutoff function Yε. Input arguments:\n\nx: point at which the cutoff function is evaluated\ncache: see IntegrationCache\n\nReturns the value of the cutoff function at x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.Yε_1st_der-Union{Tuple{T}, Tuple{T, QPGreen.IntegrationCache}} where T","page":"Docstrings","title":"QPGreen.Yε_1st_der","text":"Yε_1st_der(x, cache)\n\nBuild the derivative of the cutoff function Yε. Input arguments:\n\nx: point at which the derivative of the cutoff function is evaluated\ncache: see IntegrationCache\n\nReturns the value of the derivative of the cutoff function at x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.Yε_2nd_der-Union{Tuple{T}, Tuple{T, QPGreen.IntegrationCache}} where T","page":"Docstrings","title":"QPGreen.Yε_2nd_der","text":"Yε_2nd_der(x, cache)\n\nBuild the 2nd derivative of the cutoff function Yε. Input arguments:\n\nx: point at which the 2nd derivative of the cutoff function is evaluated\ncache: see IntegrationCache\n\nReturns the value of the 2nd derivative of the cutoff function at x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.asin_ls-Tuple{Any}","page":"Docstrings","title":"QPGreen.asin_ls","text":"asin_ls(x)\n\nCompute the inverse sine function (arcsine function) for values outside of the interval [-1,1]. Input arguments:\n\nx: real values outside the interval [-1,1].\n\nReturns the inverse sine function (arcsine function) evaluated at x. For values inside the interval [-1,1], use the standard asin function.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.bernoulli-Tuple{Integer, Any}","page":"Docstrings","title":"QPGreen.bernoulli","text":"bernoulli(n, x)\n\nCompute the Bernoulli polynomial of degree n evaluated at x. Input arguments:\n\nn: degree of the Bernoulli polynomial.\nx: value at which the polynomial is evaluated.\n\nReturns the nth Bernoulli polynomial evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.eigfunc_expansion-Tuple{Any, NamedTuple}","page":"Docstrings","title":"QPGreen.eigfunc_expansion","text":"eigfunc_expansion(z, csts; period=2π, nb_terms=100)\n\nz: coordinates of the difference between the target point and source point\ncsts: Named tuple of the constants for the problem definition\n\nReturns the value of the α-quasi-periodic Green function for 2D Helmholtz equation at the point z defined by the basic eigenfunction expansion.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.eigfunc_expansion_derivative-Tuple{Any, NamedTuple}","page":"Docstrings","title":"QPGreen.eigfunc_expansion_derivative","text":"eigfunc_expansion_derivative(z, csts; period=2π, nb_terms=100)\n\nCalculate the derivative of the Green's function using the eigenfunction expansion. Input arguments:\n\nz: coordinates of the difference between the target point and source point\ncsts: Named tuple of the constants for the problem definition\n\nReturns the value of the derivative of the α-quasi-periodic Green function for 2D Helmholtz equation at the point z.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.ewald-Tuple{Any, Any}","page":"Docstrings","title":"QPGreen.ewald","text":"ewald(z, csts)\n\nEvaluation of the Green's function using Ewald's method. Input arguments:\n\nz: coordinates.\ncsts: tuple of constants (a, M₁, M₂, N, β, k, d).\n\nReturns the value of the Green's function at the point z.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.fm_method_calculation-Union{Tuple{T}, Tuple{Any, NamedTuple, T, QPGreen.IntegrationCache}} where T","page":"Docstrings","title":"QPGreen.fm_method_calculation","text":"fm_method_calculation(x, csts, interp_cubic, cache_Yε; nb_terms=100)\n\nCalculation step of the FFT-based algorithm. Input arguments:\n\nx: given as a 2D array\ncsts: tuple of the constants (α, k, c, c̃, ε, order)\ninterp_cubic: bicubic interpolation function\ncache_Yε: cache for the cut-off function Yε\n\nKeyword arguments:\n\n  - nb_terms: number of terms in the series expansion\n\nReturns the approximate value of the Green's function G(x).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.fm_method_calculation_derivative-Union{Tuple{T2}, Tuple{T1}, Tuple{Any, NamedTuple, T1, T2, QPGreen.IntegrationCache}} where {T1, T2}","page":"Docstrings","title":"QPGreen.fm_method_calculation_derivative","text":"fm_method_calculation_derivative(x, csts, interp_cubic_x1, interp_cubic_x2, cache_Yε; nb_terms=100)\n\nCalculate the first order derivative of the Green's function using the FFT-based method.\n\nInput arguments:\n\nx: The point at which the Green's function is evaluated.\ncsts: A NamedTuple containing the parameters of the problem.\ninterp_cubic_x1: bicubic interpolation function for the first component of the Green's function.\ninterp_cubic_x2: bicubic interpolation function for the second component of the Green's function.\ncache_Yε: IntegrationCache for the cutoff functions.\n\nKeyword arguments:\n\n- `nb_terms`: Number of terms in the series expansion.\n\nReturns the approximate value of the first order derivative of the Green's function at the point x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.fm_method_calculation_derivative_smooth-Union{Tuple{T2}, Tuple{T1}, Tuple{Any, NamedTuple, T1, T2, QPGreen.IntegrationCache}} where {T1, T2}","page":"Docstrings","title":"QPGreen.fm_method_calculation_derivative_smooth","text":"fm_method_calculation_derivative_smooth(x, csts, interp_cubic_x1, interp_cubic_x2, cache_Yε; nb_terms=100)\n\nCalculate the first order derivative of the analytic part of the Green's function using the FFT-based method.\n\nInput arguments:\n\nx: The point at which the Green's function is evaluated.\ncsts: A NamedTuple containing the parameters of the problem.\ninterp_cubic_x1: bicubic interpolation function for the first component of the Green's function.\ninterp_cubic_x2: bicubic interpolation function for the second component of the Green's function.\ncache_Yε: IntegrationCache for the cutoff functions.\n\nKeyword arguments:\n\n- `nb_terms`: Number of terms in the series expansion.\n\nReturns the approximate value of the first order derivative of the analytic part of the Green's function at the point x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.fm_method_calculation_hankel-Union{Tuple{T}, Tuple{Any, NamedTuple, T, QPGreen.IntegrationCache}} where T","page":"Docstrings","title":"QPGreen.fm_method_calculation_hankel","text":"fm_method_calculation_hankel(x, csts, interp_cubic, cache_Yε; nb_terms=100)\n\nCalculation step of the FFT-based algorithm. Input arguments:\n\nx: given as a 2D array\ncsts: tuple of the constants (α, k, c, c̃, ε, order)\ninterp_cubic: bicubic interpolation function\ncache_Yε: cache for the cut-off function Yε\n\nKeyword arguments:\n\n  - nb_terms: number of terms in the series expansion\n\nReturns the approximate value of the Green's function G(x).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.fm_method_calculation_smooth-Union{Tuple{T}, Tuple{Any, NamedTuple, T, QPGreen.IntegrationCache}} where T","page":"Docstrings","title":"QPGreen.fm_method_calculation_smooth","text":"fm_method_calculation_smooth(x, csts, interp_cubic, cache_Yε; nb_terms=100)\n\nCalculation step of the FFT-based algorithm for the analytic function G_0. Input arguments:\n\nx: given as a 2D array\ncsts: tuple of the constants (α, k, c, c̃, ε, order)\ninterp_cubic: bicubic interpolation function\ncache_Yε: cache for the cut-off function Yε\n\nKeyword arguments:\n\n  - nb_terms: number of terms in the series expansion\n\nReturns the approximate value of the Green's function G(x).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.fm_method_calculation_smooth_hankel-Union{Tuple{T}, Tuple{Any, NamedTuple, T, QPGreen.IntegrationCache}} where T","page":"Docstrings","title":"QPGreen.fm_method_calculation_smooth_hankel","text":"fm_method_calculation_smooth(x, csts, interp_cubic, cache_Yε; nb_terms=100)\n\nCalculation step of the FFT-based algorithm for the analytic function G_0. Input arguments:\n\nx: given as a 2D array\ncsts: tuple of the constants (α, k, c, c̃, ε, order)\ninterp_cubic: bicubic interpolation function\ncache_Yε: cache for the cut-off function Yε\n\nKeyword arguments:\n\n  - nb_terms: number of terms in the series expansion\n\nReturns the approximate value of the Green's function G(x).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.fm_method_preparation-Tuple{NamedTuple, Integer}","page":"Docstrings","title":"QPGreen.fm_method_preparation","text":"fm_method_preparation(csts, grid_size)\n\nPreparation step of the FFT-based algorithm. Input arguments:\n\ncsts: tuple of constants (α, k, c, c̃, ε, order) (recommended value: 0.4341)\ngrid_size: size of the grid\n\nReturns the Fourier coefficients of the function Lₙ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.fm_method_preparation_derivative-Tuple{NamedTuple, Integer}","page":"Docstrings","title":"QPGreen.fm_method_preparation_derivative","text":"fm_method_preparation_derivative(csts, grid_size)\n\nPreparation of the Fourier coefficients for the first order derivative of the Green's function.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.fm_method_preparation_hankel-Tuple{NamedTuple, Integer}","page":"Docstrings","title":"QPGreen.fm_method_preparation_hankel","text":"fm_method_preparation_hankel(csts, grid_size)\n\nPreparation step of the FFT-based algorithm. Input arguments:\n\ncsts: tuple of constants (α, k, c, c̃, ε, order) (recommended value: 0.4341)\ngrid_size: size of the grid\n\nReturns the Fourier coefficients of the function Lₙ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.f₁-Tuple{Any, QPGreen.IntegrationCache}","page":"Docstrings","title":"QPGreen.f₁","text":"f₁(x, Yε)\n\nCalculate the function f₁. Input arguments:\n\nx: point at which the function is evaluated\nYε: cut-off function Yε\n\nReturns the value of the function f₁.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.f₂-Tuple{Any, QPGreen.IntegrationCache}","page":"Docstrings","title":"QPGreen.f₂","text":"f₂(x, cache)\n\nCalculate the function f₂. Input arguments:\n\nx: point at which the function is evaluated\ncache: cache for the cut-off function Yε\n\nReturns the value of the function f₂.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.get_F̂ⱼ-Union{Tuple{type_α}, Tuple{Any, Any, Any, Any, Any, Complex{type_α}, Type{type_α}}} where type_α","page":"Docstrings","title":"QPGreen.get_F̂ⱼ","text":"get_F̂ⱼ(j₁, j₂, c̃, Φ̂₁ⱼ, Φ̂₂ⱼ, F̂₁ⱼ₀, type_α)\n\nCalculate the Fourier coefficients F̂ⱼ. Input arguments:\n\nj₁: first index\nj₂: second index\nc̃: parameter of the periodicity\nΦ̂₁ⱼ: Fourier coefficients of the function Φ₁\nΦ̂₂ⱼ: Fourier coefficients of the function Φ₂\nF̂₁ⱼ₀: Fourier coefficient of the function F₁ at |j| = 0\ntype_α: type of the parameter α\n\nReturns the Fourier coefficients F̂ⱼ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.get_K̂ⱼ!-Union{Tuple{T}, Tuple{Any, Any, Any, Any, QPGreen.FFT_cache{T}, QPGreen.IntegrationCache, Any}} where T","page":"Docstrings","title":"QPGreen.get_K̂ⱼ!","text":"get_K̂ⱼ!((K̂ⱼ, csts, N, i, fft_cache, cache, p)\n\nMutating function that computes the Fourier coefficients K̂ⱼ. Input arguments:\n\nK̂ⱼ: matrix to store the Fourier coefficients\ncsts: Named tuple of the constants for the problem definition\nN: size of the grid\ni: index of the grid points\nfft_cache: cache for the FFT\ncache: cache for the cut-off function Yε\np: plan for the FFT\n\nReturns the Fourier coefficients K̂ⱼ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.get_t-Tuple{Any}","page":"Docstrings","title":"QPGreen.get_t","text":"get_t(x)\n\nFind the value of t in the interval [-π, π[ such that x = 2nπ + t. Input arguments:\n\nx: point at which the function is evaluated\n\nReturns the value of t.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.get_Ĥⱼ-Union{Tuple{type_α}, Tuple{Any, Any, NamedTuple, Any, Any, Any, Any, Any, Any, Complex{type_α}, Type{type_α}}} where type_α","page":"Docstrings","title":"QPGreen.get_Ĥⱼ","text":"get_Ĥⱼ(j₁, j₂, csts, F̂₁ⱼ, F̂₂ⱼ, ρ̂ₓⱼ, Φ̂₃ⱼ, ĥ₁ⱼ, ĥ₂ⱼ, Ĥ₁ⱼ₀, type_α)\n\nCalculate the Fourier coefficients Ĥⱼ. Input arguments:\n\n- j₁: first index\n- j₂: second index\n- csts: Named tuple of the constants for the problem definition\n- F̂₁ⱼ: Fourier coefficients of the function F₁\n- F̂₂ⱼ: Fourier coefficients of the function F₂\n- ρ̂ₓⱼ: Fourier coefficients of the function ρₓ\n- Φ̂₃ⱼ: Fourier coefficients of the function Φ₃\n- ĥ₁ⱼ: Fourier coefficients of the function h₁_reduced\n- ĥ₂ⱼ: Fourier coefficients of the function h₂_reduced\n- Ĥ₁ⱼ₀: Fourier coefficient of the function H₁ at |j| = 0\n- type_α: type of the parameter α\n\nReturns the Fourier coefficients Ĥⱼ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.h₁-Tuple{Any, Any, QPGreen.IntegrationCache}","page":"Docstrings","title":"QPGreen.h₁","text":"h₁(x, csts, cache)\n\nCalculate the function h₁. Input arguments:\n\nx: point at which the function is evaluated\ncsts: Named tuple of the constants for the problem definition\n\nReturns the value of the function h₁.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.h₂-Tuple{Any, Any, QPGreen.IntegrationCache}","page":"Docstrings","title":"QPGreen.h₂","text":"h₂(x, csts, cache)\n\nCalculate the function h₂. Input arguments:\n\nx: point at which the function is evaluated\ncsts: Named tuple of the constants for the problem definition\n\nReturns the value of the function h₂.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.image_expansion-Tuple{Any, NamedTuple}","page":"Docstrings","title":"QPGreen.image_expansion","text":"image_expansion(z, csts; period=2π, nb_terms=100)\n\nz: coordinates of the difference between the target point and source point\ncsts: Named tuple of the constants for the problem definition\n\nReturns the value of the α-quasi-periodic Green function for 2D Helmholtz equation at the point z defined by the basic image expansion.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.image_expansion_derivative-Tuple{Any, NamedTuple}","page":"Docstrings","title":"QPGreen.image_expansion_derivative","text":"image_expansion_derivative(z, csts; period=2π, nb_terms=100)\n\nCalculate the derivative of the Green's function using the image expansion. Input arguments:\n\nz: coordinates of the difference between the target point and source point\ncsts: Named tuple of the constants for the problem definition\n\nReturns the value of the derivative of the α-quasi-periodic Green function for 2D Helmholtz equation at the point z.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.image_expansion_derivative_smooth-Tuple{Any, NamedTuple}","page":"Docstrings","title":"QPGreen.image_expansion_derivative_smooth","text":"image_expansion_derivative_smooth(z, csts; period=2π, nb_terms=100)\n\nCalculate the analytic part of the derivative of the Green's function using the image expansion.\n\nz: coordinates of the difference between the target point and source point\ncsts: Named tuple of the constants for the problem definition\n\nReturns the value of the derivative of the α-quasi-periodic Green function for 2D Helmholtz equation at the point z.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.image_expansion_smooth-Tuple{Any, NamedTuple}","page":"Docstrings","title":"QPGreen.image_expansion_smooth","text":"image_expansion_smooth(z, csts; period=2π, nb_terms=100)\n\nCalculate the analytic part of the Green's function using the image expansion.\n\nz: coordinates of the difference between the target point and source point\ncsts: Named tuple of the constants for the problem definition\n\nReturns the value of the α-quasi-periodic Green function for 2D Helmholtz equation at the point z.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.lattice_sums_calculation-Tuple{Any, Any, AbstractArray}","page":"Docstrings","title":"QPGreen.lattice_sums_calculation","text":"lattice_sums_calculation(x, csts, Sₗ; c=0.6, nb_terms=100)\n\nCompute the Green's function using lattice sums. Input arguments:\n\nx: evaluation point\ncsts: tuple of constants (β, k, d, M, L)\nSₗ: lattice sum coefficients\nc: cutoff value\nnb_terms: number of terms in the sum\n\nKeyword arguments:\n\nc: cutoff value\nnb_terms: number of terms in the sum\n\nReturns the value of the Green's function at the point x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.lattice_sums_preparation-Tuple{Any}","page":"Docstrings","title":"QPGreen.lattice_sums_preparation","text":"lattice_sums_preparation(csts)\n\nPerform the preparation step for the lattice sums algorithm. Input arguments:\n\ncsts: tuple of constants (β, k, d, M, L) representing quasi-periodicty parameter, wave number , period, number of terms, and number of terms in the sum respectively.\n\nReturns the lattice sum coefficients.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.rfftshift_normalization!-NTuple{4, Any}","page":"Docstrings","title":"QPGreen.rfftshift_normalization!","text":"rfftshift_normalization!(Φ̂₁ⱼ, fft_Φ₁_eval, N, c̃)\n\nShift the Fourier coefficients obtained by rfft and normalize them.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.χ-Union{Tuple{T}, Tuple{T, QPGreen.IntegrationCache}} where T","page":"Docstrings","title":"QPGreen.χ","text":"χ(x, cache)\n\nBuild the cutoff function χ. Input arguments:\n\nx: point at which the cutoff function is evaluated\ncache: see IntegrationCache\n\nReturns the value of the cutoff function at x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#QPGreen.χ_der-Union{Tuple{T}, Tuple{T, QPGreen.IntegrationCache}} where T","page":"Docstrings","title":"QPGreen.χ_der","text":"χ_der(x, cache)\n\nBuild the derivative of the cutoff function χ. Input arguments:\n\nx: point at which the derivative of the cutoff function is evaluated\ncache: see IntegrationCache\n\nReturns the value of the derivative of the cutoff function at x.\n\n\n\n\n\n","category":"method"}]
}
