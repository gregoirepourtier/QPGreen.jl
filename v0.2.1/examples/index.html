<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · QPGreen.jl</title><meta name="title" content="Examples · QPGreen.jl"/><meta property="og:title" content="Examples · QPGreen.jl"/><meta property="twitter:title" content="Examples · QPGreen.jl"/><meta name="description" content="Documentation for QPGreen.jl."/><meta property="og:description" content="Documentation for QPGreen.jl."/><meta property="twitter:description" content="Documentation for QPGreen.jl."/><meta property="og:url" content="https://gregoirepourtier.github.io/QPGreen.jl/examples/"/><meta property="twitter:url" content="https://gregoirepourtier.github.io/QPGreen.jl/examples/"/><link rel="canonical" href="https://gregoirepourtier.github.io/QPGreen.jl/examples/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QPGreen.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Example-1:-FFT-based-algorithm"><span>Example 1: FFT-based algorithm</span></a></li><li class="toplevel"><a class="tocitem" href="#Example-2:-Lattice-sums-algorithm"><span>Example 2: Lattice sums algorithm</span></a></li><li class="toplevel"><a class="tocitem" href="#Example-3:-Ewald&#39;s-method"><span>Example 3: Ewald&#39;s method</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gregoirepourtier/QPGreen.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gregoirepourtier/QPGreen.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>We show here some examples on how to compute efficiently Quasi-periodic Green Functions and its first derivatives for the 2D Helmholtz equation. The main focus is on the FFT-based algorithm, but we also provide examples for the lattice sums and Ewald summation algorithms.</p><h1 id="Example-1:-FFT-based-algorithm"><a class="docs-heading-anchor" href="#Example-1:-FFT-based-algorithm">Example 1: FFT-based algorithm</a><a id="Example-1:-FFT-based-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-FFT-based-algorithm" title="Permalink"></a></h1><p>The first example is concerned with computing the quasi-periodic Green function for the 2D Helmholtz equation using the <strong>FFT-based algorithm</strong> (based on the article [<a href="../references/#Zhang2018">1</a>]).</p><p>First, load the package, using the following command:</p><pre><code class="language-julia hljs">using QPGreen</code></pre><p>Then initialize the different parameters, as a NamedTuple, that define your problems. We have</p><pre><code class="language-julia hljs"># Parameters
params = (alpha=0.3, k=1.0, c=0.6, c_tilde=1.0, epsilon=0.45, order=8)</code></pre><p>The parameters are defined as follows:</p><ul><li><code>alpha</code> is the quasiperiod, </li><li><code>k</code> is the wavenumber, </li><li><code>c</code> and <code>c_tilde</code> are the coefficients introduced in [<a href="../references/#Zhang2018">1</a>] that define the vertical bounds of the computational domains used in the FFT-based algorithm, determining the regions where interpolation and Fourier-based approximations are valid (consider <span>$x=(x_1, x_2) \in \mathbb{R}^2$</span>, then if <span>$|x_2| &gt; c$</span> the we use the eigenfunction expansion, else the FFT-based algo),</li></ul><div class="admonition is-info" id="Note-on-the-choice-of-c-and-c_tilde-82c2b23eae7e89b8"><header class="admonition-header">Note on the choice of c and c_tilde<a class="admonition-anchor" href="#Note-on-the-choice-of-c-and-c_tilde-82c2b23eae7e89b8" title="Permalink"></a></header><div class="admonition-body"><p>The following inequality must hold:</p><p class="math-container">\[    0 &lt; \text{c} &lt; \text{c_tilde}\]</p></div></div><ul><li><code>epsilon</code> controls the support of smooth cutoff functions used to isolate and remove singularities,</li><li><code>order</code> denotes the regularity from the cut-off functions.</li></ul><p>We set the grid size used to generate the 2D tensor product mesh (adjust for desired accuracy).</p><pre><code class="language-julia hljs"># Size of the Grid
grid_size = 128</code></pre><p>This method relies on two steps: a <strong>preparation</strong> step and an <strong>evaluation</strong> step. </p><h3 id="Preparation-step"><a class="docs-heading-anchor" href="#Preparation-step">Preparation step</a><a id="Preparation-step-1"></a><a class="docs-heading-anchor-permalink" href="#Preparation-step" title="Permalink"></a></h3><p>The preparation step, independent of evaluating the function at specific points, computes the necessary Fourier coefficients and produces an interpolation object for function and gradient evaluation (if the flag is true), along with a cache of integral approximations. This step needs to be performed only once for a fixed set of parameters and grid resolution.</p><pre><code class="language-julia hljs"># Preparation Step
value_interpolator, grad_interpolator, cache = init_qp_green_fft(params, grid_size; derivative=true)</code></pre><h3 id="Evaluation-step"><a class="docs-heading-anchor" href="#Evaluation-step">Evaluation step</a><a id="Evaluation-step-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-step" title="Permalink"></a></h3><p>The evaluation step efficiently computes the Green’s function and its first derivative at any specified point within the periodic domain.</p><pre><code class="language-julia hljs"># Evaluation Step for any points
Z = (0.002π, 0.01)
eval_Green_function = eval_qp_green(Z, params, value_interpolator, cache; nb_terms=50)
grad_Green_function = grad_qp_green(Z, params, grad_interpolator, cache; nb_terms=50)
@show &quot;The value of the Green function at the point $(Z) is: $(eval_Green_function)&quot;
@show &quot;The value of the gradient of the Green function at the point $(Z) is: $(grad_Green_function)&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;The value of the gradient of the Green function at the point (0.006283185307179587, 0.01) is: ComplexF64[-7.1188161590804295 + 0.06215371863722293im, -11.4148584648968 - 0.0013267471845958868im]&quot;</code></pre><p>Note here that the keyword argument <code>nb_terms</code> is used to control the number of terms in the eigenfunction expansion (in the case where the FFT-based algorithm is not used).</p><h1 id="Example-2:-Lattice-sums-algorithm"><a class="docs-heading-anchor" href="#Example-2:-Lattice-sums-algorithm">Example 2: Lattice sums algorithm</a><a id="Example-2:-Lattice-sums-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Lattice-sums-algorithm" title="Permalink"></a></h1><div class="admonition is-warning" id="Work-in-progress-c0d47da6248ee3d8"><header class="admonition-header">Work in progress<a class="admonition-anchor" href="#Work-in-progress-c0d47da6248ee3d8" title="Permalink"></a></header><div class="admonition-body"><p>This algorithm is still a work in progress.</p></div></div><p>The second algorithm implemented is the <strong>lattice sums algorithm</strong> (implementation was done based on the article [<a href="../references/#Linton1998">2</a>]).</p><p>Once again, load the package, using the following command:</p><pre><code class="language-julia hljs">using QPGreen</code></pre><p>Then initialize the different parameters, as a NamedTuple, that define your problems. We have</p><pre><code class="language-julia hljs">X, Y = (0.0, 0.01 * 2π)

β, k, d, M, L = (√2 / (2 * π), 1 / π, 2 * π, 80, 4)
csts = (β, k, d, M, L)

Sl = QPGreen.lattice_sums_preparation(csts);
eval_ls = QPGreen.lattice_sums_calculation((X, Y), csts, Sl; nb_terms=100)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.4595073481223693 - 0.35087920819684576im</code></pre><div class="admonition is-info" id="Note-b2580a1535297036"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b2580a1535297036" title="Permalink"></a></header><div class="admonition-body"><p>The implementation for the derivatives is missing at the moment.</p></div></div><h1 id="Example-3:-Ewald&#39;s-method"><a class="docs-heading-anchor" href="#Example-3:-Ewald&#39;s-method">Example 3: Ewald&#39;s method</a><a id="Example-3:-Ewald&#39;s-method-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Ewald&#39;s-method" title="Permalink"></a></h1><div class="admonition is-warning" id="Work-in-progress-c0d47da6248ee3d8"><header class="admonition-header">Work in progress<a class="admonition-anchor" href="#Work-in-progress-c0d47da6248ee3d8" title="Permalink"></a></header><div class="admonition-body"><p>This algorithm is still a work in progress.</p></div></div><p>The last algorithm implemented is the <strong>Ewald summation algorithm</strong> (implementation was done based on the article [<a href="../references/#Linton1998">2</a>]).</p><p>Load the package, using the following command:</p><pre><code class="language-julia hljs">using QPGreen</code></pre><p>Then initialize the different parameters, as a NamedTuple, that define your problems. We have</p><pre><code class="language-julia hljs">(X, Y) = (0.0, 0.01 * 2π)

a, M₁, M₂, N, β, k, d = (2, 3, 2, 7, √2 / (2 * π), 1 / π, 2 * π)
csts = (a, M₁, M₂, N, β, k, d)

res_ewald = QPGreen.ewald([X, Y], csts)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.4595298794735017 - 0.3509130869382092im</code></pre><div class="admonition is-info" id="Note-b2580a1535297036"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b2580a1535297036" title="Permalink"></a></header><div class="admonition-body"><p>The implementation for the derivatives is missing at the moment.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Saturday 24 May 2025 16:26">Saturday 24 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
